#!/bin/sh

# -----------------------------------------------------------------------------
# BSD 2-Clause License
#
# Copyright (c) 2023, stonewall (stonewall@sacredheartsc.com)
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# -----------------------------------------------------------------------------
#                                    JMJ

# Shellcheck doesn't support FreeBSD's /bin/sh, but we can get pretty close:
# shellcheck shell=dash disable=SC3033
:

set -eu -o pipefail

cmd::main(){
  local usage="COMMAND [ARGS]...
Commands:
  create                Create a new jail
  create-snapshot|snap  Take a snapshot of a jail
  create-template       Create a template from a jail
  destroy-snapshot|rms  Delete a jail snapshot
  destroy-template|rmt  Delete a template
  destroy|rm            Delete a jail and its dataset
  download-release      Download and create a FreeBSD release template
  edit                  Edit a jail's configuration
  exec                  Run a command within the jail
  init                  Initialize the jail dataset
  list-snapshots|lss    List jail snapshots
  list-templates|lst    List available templates
  list|ls               List configured jails
  reprovision           Wipe and reprovision an OS dataset from template
  restart               Restart a jail
  rollback              Rollback a jail to a given snapshot
  shell|sh              Run a shell within the jail
  show                  Show jail configuration
  start                 Start a jail
  status                Show running jail status
  stop                  Stop a jail
  update-release        Update a FreeBSD release template"

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -ge 1 ] || cmd::usage 'no comand specified'
  local cmd=$1
  shift

  case $cmd in
    create)                cmd::create "$@" ;;
    create-snapshot|snap)  cmd::create_snapshot "$@" ;;
    create-template)       cmd::create_template "$@" ;;
    destroy-snapshot|rms)  cmd::destroy_snapshot "$@" ;;
    destroy-template|rmt)  cmd::destroy_template "$@" ;;
    destroy|rm)            cmd::destroy "$@" ;;
    download-release)      cmd::download_release "$@" ;;
    edit)                  cmd::edit "$@" ;;
    exec)                  cmd::exec "$@" ;;
    init)                  cmd::init "$@" ;;
    list-snapshots|lss)    cmd::list_snapshots "$@" ;;
    list-templates|lst)    cmd::list_templates "$@" ;;
    list|ls)               cmd::list "$@" ;;
    reprovision)           cmd::reprovision "$@" ;;
    restart)               cmd::restart "$@" ;;
    rollback)              cmd::rollback "$@" ;;
    shell|sh)              cmd::shell "$@" ;;
    show)                  cmd::show "$@" ;;
    start)                 cmd::start "$@" ;;
    status)                cmd::status "$@" ;;
    stop)                  cmd::stop "$@" ;;
    update-release)        cmd::update_release "$@" ;;
    *)                     cmd::usage "unknown command: ${cmd}" ;;
  esac
}


################################################################################
# Global variable definitions.
################################################################################
readonly JAIL_HOME=/usr/local/jails
readonly JAIL_DATASET=zroot/jails

# shellcheck disable=SC2155
readonly DEFAULT_DOMAIN=$(hostname -d)
readonly DEFAULT_INTERFACE=vtnet0
readonly DEFAULT_NETMASK=255.255.255.0
readonly DEFAULT_OS_QUOTA=24G
readonly DEFAULT_DATA_QUOTA=8G

# Leave these values alone.
readonly JAIL_BPF_RULESET=1000
readonly DEFAULT_DEVFS_RULESET=5


################################################################################
# Standard helper functions.
################################################################################
die(){
  printf '%s: %s\n' jailctl "$*" 1>&2
  exit 1
}


################################################################################
# CLI-related functions.
################################################################################
cmd::help(){
  printf 'Usage: %s %s\n' jailctl "$usage"
  [ -n "${help:-}" ] && printf '%s\n' "$help"
  exit 0
}

cmd::usage(){
  [ $# -gt 0 ] && printf '%s: %s\n' "jailctl" "$1" 1>&2
  printf 'Usage: %s %s\n' jailctl "${usage}" 1>&2
  exit 2
}

cmd::getopt_help(){
  local opt
  while getopts :h opt; do
    case $opt in
      h) cmd::help ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
}

cmd::create(){
  local usage='create [-a IP] [-b] [-c CPULIMIT] [-d DOMAIN] [-g GATEWAY] [-i INTERFACE]
        [-k SSHKEY] [-m MEMLIMIT] [-n NETMASK] [-q QUOTA] [-Q OS_QUOTA] [-r NAMESERVER]
        [-s SEARCHDOMAIN] NAME TEMPLATE'
  local help="Create a new jail.
Options:
  -a IP            IPv4 address
  -b               Enable BPF device (allows DHCP, tcpdump, etc)
  -c CPULIMIT      %CPU limit (100 for one core, 200 for two cores, etc)
  -d DOMAIN        Host domain name
  -g GATEWAY       Default IPv4 gateway.
  -i INTERFACE     Host network interface to bridge
  -k SSHKEY        Path to SSH pubkey for root's authorized_keys
  -m MEMLIMIT      Virtual memory limit
  -n NETMASK       IPv4 netmask
  -q QUOTA         Quota for delegated dataset
  -Q OS_QUOTA      Quota for root filesystem
  -r NAMESERVER    DNS resolver
  -s SEARCHDOMAIN  DNS search domain"

  local \
    devfs_ruleset=$DEFAULT_DEVFS_RULESET \
    jail_bpf=false \
    jail_cpulimit \
    jail_data_quota \
    jail_domain=$DEFAULT_DOMAIN \
    jail_interface=$DEFAULT_INTERFACE \
    jail_ip='' \
    jail_memlimit \
    jail_nameservers \
    jail_netmask=$DEFAULT_NETMASK \
    jail_data_quota=$DEFAULT_DATA_QUOTA \
    jail_os_quota=$DEFAULT_OS_QUOTA \
    jail_searchdomains \
    jail_sshkey \
    snapshot \
    opt
  local jail_gateway="${jail_ip%.*}.1"

  while getopts :a:bc:d:g:hi:k:m:n:q:Q:r:s: opt; do
    case $opt in
      a) jail_ip=$OPTARG ;;
      b) jail_bpf=true ;;
      c) jail_cpulimit=$OPTARG ;;
      d) jail_domain=$OPTARG ;;
      g) jail_gateway=$OPTARG ;;
      h) cmd::help ;;
      i) jail_interface=$OPTARG ;;
      k) jail_sshkey=$OPTARG ;;
      m) jail_memlimit=$OPTARG ;;
      n) jail_netmask=$OPTARG ;;
      q) jail_data_quota=$OPTARG ;;
      Q) jail_os_quota=$OPTARG ;;
      r) jail_nameservers="${jail_nameservers:-} ${OPTARG}" ;;
      s) jail_searchdomains="${jail_searchdomains:-} ${OPTARG}" ;;
      :) cmd::usage "missing option value: -${OPTARG}" ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'NAME not specified'
  [ $# -lt 2 ] && cmd::usage 'TEMPLATE not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  local name=$1 template=$2

  jail::exists "$name"                && die "jail name already in use: ${name}"
  jail::template::exists "$template"  || die "no such template: ${template}"
  interface::exists "$jail_interface" || die "no such interface: ${jail_interface}"

  if [ -n "${jail_sshkey:-}" ]; then
    [ -f "$jail_sshkey" ] || die "ssh key ${jail_sshkey}: file not found"
  fi

  zfs::ensure_snapshot snapshot "${JAIL_DATASET}/templates/${template}"

  # Clone template into new 'os' dataset.
  zfs create -v -o mountpoint=none "${JAIL_DATASET}/${name}"
  zfs clone \
    -o mountpoint="${JAIL_HOME}/${name}" \
    -o quota="$jail_os_quota" \
    "$snapshot" "${JAIL_DATASET}/${name}/os"
  chmod 700 "${JAIL_HOME}/${name}"

  # Create delegated 'data' dataset.
  zfs create -v \
    -o mountpoint=none \
    -o quota="$jail_data_quota" \
    "${JAIL_DATASET}/${name}/data"

  # Copy timezone configuration from host.
  cp -v /etc/localtime "${JAIL_HOME}/${name}/etc/localtime"

  # Generate /etc/resolv.conf in the jail (word-splitting intentional).
  # shellcheck disable=SC2086
  [ -n "${jail_nameservers:-}"   ] && printf 'nameserver %s\n' $jail_nameservers     >> "${JAIL_HOME}/${name}/etc/resolv.conf"
  [ -n "${jail_searchdomains:-}" ] && printf 'search %s\n'     "$jail_searchdomains" >> "${JAIL_HOME}/${name}/etc/resolv.conf"

  # Get the jail's virtual interface name.
  local vnet_interface
  vnet_interface=$(jail::name2intf "$name")

  # Set /etc/rc.conf values within the jail.
  sysrc -v -f "${JAIL_HOME}/${name}/etc/rc.conf" \
    "hostname=${name}.${jail_domain}" \
    "ifconfig_e0b_${vnet_interface}_name=jail0" \
    'ipv6_activate_all_interfaces=NO' \
    'syslogd_flags=-ss' \
    'sendmail_enable=NONE' \
    'dumpdev=NO'

  if [ -n "${jail_ip}" ]; then
    # If $jail_ip set, configure /etc/rc.conf for static IP.
    sysrc -v -f "${JAIL_HOME}/${name}/etc/rc.conf" \
      "ifconfig_jail0=inet ${jail_ip} netmask ${jail_netmask}" \
      "defaultrouter=${jail_gateway}"
  else
    # Othersie, configure /etc/rc.conf for DHCP.
    sysrc -v -f "${JAIL_HOME}/${name}/etc/rc.conf" "ifconfig_jail0=SYNCDHCP"
    devfs_ruleset=$JAIL_BPF_RULESET
  fi

  if [ -n "${jail_sshkey:-}" ]; then
    # If $jail_sshkey set, enable sshd and root login.
    echo "PermitRootLogin prohibit-password" | tee -a "${JAIL_HOME}/${name}/etc/ssh/sshd_config"
    sysrc -v -f "${JAIL_HOME}/${name}/etc/rc.conf" 'sshd_enable=YES'
    # Copy the ssh key into root's authorized_keys within the jail.
    install -v -d -m 0700 "${JAIL_HOME}/${name}/root/.ssh"
    install -v -m 0600 "$jail_sshkey" "${JAIL_HOME}/${name}/root/.ssh/authorized_keys"
  fi

  # If BPF requested, use our custom bpf ruleset.
  [ "${jail_bpf}" = true ] && devfs_ruleset=$JAIL_BPF_RULESET

  # Generate jail config file.
  cat <<EOF > "/etc/jail.conf.d/${name}.conf"
${name} {
  path = "${JAIL_HOME}/\$name";
  host.hostname = "\$name.${jail_domain}";

  exec.created  = "zfs set jailed=on ${JAIL_DATASET}/\$name/data";
  exec.created += "zfs jail \$name ${JAIL_DATASET}/\$name/data";
  exec.start    = "zfs mount -a";
  exec.start   += "/bin/sh /etc/rc";
  exec.stop     = "/bin/sh /etc/rc.shutdown";
  exec.clean;

  exec.system_user = "root";
  exec.jail_user   = "root";

  mount.devfs;
  devfs_ruleset = "${devfs_ruleset}";

  allow.mount     = true;
  allow.mount.zfs = true;
  enforce_statfs  = 1;

  vnet;
  vnet.interface = "e0b_${vnet_interface}";
  exec.prestart = "jib addm ${vnet_interface} ${jail_interface}";
  exec.poststop = "jib destroy ${vnet_interface}";
}
EOF

  # Configure rctl resource limits.
  [ -n "${jail_cpulimit:-}" ] && rctl -a "jail:${name}:pcpu:deny=${jail_cpulimit}"
  [ -n "${jail_memlimit:-}" ] && rctl -a "jail:${name}:vmemoryuse:deny=${jail_memlimit}"

  # Update host's /etc/rc.conf to start the jail on boot.
  sysrc -v jail_list+="$name"

  # Start the jail.
  jail::start "$name"
}

cmd::create_snapshot(){
  local usage='create-snapshot [-d] [-o] JAIL [SNAPNAME]'
  local help='Create a jail snapshot.
Options:
  -d  Only snapshot the data dataset
  -o  Only snapshot the OS dataset'

  local opt both=true os_only=false data_only=false snapname
  while getopts :dho opt; do
    case $opt in
      d) data_only=true; both=false ;;
      h) cmd::help ;;
      o) os_only=true; both=false ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  jail=$1 snapname=${2:-}

  jail::exists "$jail" || die "no such jail: ${jail}"

  [ -n "$snapname" ] || snapname=$(date +%Y-%m-%dT%H:%M:%S)

  if [ "$both" = true ] || [ "$os_only" = true ]; then
    zfs snapshot "${JAIL_DATASET}/${jail}/os@${snapname}"
  fi
  if [ "$both" = true ] || [ "$data_only" = true ]; then
    zfs snapshot "${JAIL_DATASET}/${jail}/data@${snapname}"
  fi
}

cmd::create_template(){
  local usage='create-template NAME JAIL'
  local help='Create a template from a jail.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'NAME not specified'
  [ $# -lt 2 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  local name=$1 jail=$2

  jail::exists "$jail"           || die "no such jail: ${jail}"
  jail::template::exists "$name" && die "template already exists: $name"
  jail::running "$jail"          && die "refusing to create template while jail is running: ${jail}"

  local snapname
  snapname=$(date +%Y-%m-%dT%H:%M:%S)
  zfs snapshot "${JAIL_DATASET}/${jail}/os@${snapname}"
  zfs send "${JAIL_DATASET}/${jail}/os@${snapname}" | zfs receive -v "${JAIL_DATASET}/templates/${name}"
  zfs destroy "${JAIL_DATASET}/${jail}/os@${snapname}"
}

cmd::destroy_snapshot(){
  local usage='destroy-snapshot [-y] JAIL SNAPSHOT'
  local help="Delete a jail snapshot
Options:
  -y  Don't prompt for confirmation"

  local noconfirm=false answer opt

  while getopts :hy opt; do
    case $opt in
      h) cmd::help ;;
      y) noconfirm=true ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -lt 2 ] && cmd::usage 'SNAPSHOT not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  local jail=$1 snapshot=$2

  jail::exists "$jail" || die "no such jail: ${jail}"

  local datasets=''

  if [ "${snapshot#*@}" != "$snapshot" ]; then
    zfs::dataset_exists "${JAIL_DATASET}/${jail}/${snapshot}" && \
      datasets="${JAIL_DATASET}/${jail}/${snapshot}"
  else
    zfs::dataset_exists "${JAIL_DATASET}/${jail}/os@${snapshot}" && \
      datasets="${JAIL_DATASET}/${jail}/os@${snapshot}"
    zfs::dataset_exists "${JAIL_DATASET}/${jail}/data@${snapshot}" && \
      datasets="${datasets} ${JAIL_DATASET}/${jail}/data@${snapshot}"
  fi

  [ -n "$datasets" ] || die "no such snapshot for jail ${jail}: ${snapshot}"

  if [ "$noconfirm" != true ]; then
    read -rp "Really destroy ${jail} snapshot ${snapshot}? (y/N) " answer
    case $answer in
      [yY]|[yY][eE][sS]) : ;;
      *) die 'operation cancelled' ;;
    esac
  fi

  local dataset
  # shellcheck disable=SC2086
  for dataset in $datasets; do
    zfs destroy -v "$dataset"
  done
}

cmd::destroy_template(){
  local usage='destroy-template [-y] TEMPLATE'
  local help="Delete a jail template.
Options:
  -y  Don't prompt for confirmation
Note: a template cannot be deleted while its clones still exist."

  local noconfirm=false answer opt

  while getopts :hy opt; do
    case $opt in
      h) cmd::help ;;
      y) noconfirm=true ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'TEMPLATE not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::template::exists "$1" || die "no such template: ${1}"

  if [ "$noconfirm" != true ]; then
    read -rp "Really destroy template ${1}? (y/N) " answer
    case $answer in
      [yY]|[yY][eE][sS]) : ;;
      *) die 'operation cancelled' ;;
    esac
  fi

  zfs destroy -v -r "${JAIL_DATASET}/templates/${1}"
}

cmd::destroy(){
  local usage='destroy [-y] JAIL'
  local help="Delete a jail and its dataset.
Options:
  -y  Don't prompt for confirmation"

  local noconfirm=false answer opt

  while getopts :hy opt; do
    case $opt in
      h) cmd::help ;;
      y) noconfirm=true ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'
  local jail=$1

  jail::exists "$jail" || die "no such jail: ${jail}"

  if [ "$noconfirm" != true ]; then
    read -rp "Really destroy jail ${jail}? (y/N) " answer
    case $answer in
      [yY]|[yY][eE][sS]) : ;;
      *) die 'operation cancelled' ;;
    esac
  fi

  jail::running "$1" && jail::stop "$1"

  # Delete jail config file.
  rm "/etc/jail.conf.d/${1}.conf"

  # Remove any rctl limits for the jail.
  rctl -r "jail:${1}" ||:

  # Remove the jail from the autostart list.
  sysrc -v jail_list-="$1" ||:

  # Destroy the jail's dataset.
  zfs destroy -v -r "${JAIL_DATASET}/${1}"

  # Delete the old mountpoint.
  rmdir "${JAIL_HOME}/${1}"
}

cmd::download_release() {
  local usage='download-release RELEASE'
  local help='Download and create a FreeBSD release template.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'RELEASE not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'
  local release=$1

  local template
  jail::template::release2name template "$release"

  jail::template::exists "$template" && die "template already exists: ${template}"
  jail::template::download_release "$release"
}

cmd::edit(){
  local usage='edit JAIL'
  local help='Edit jail configuration.'

  local opt
  while getopts :h opt; do
    case $opt in
      h) cmd::help ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1" || die "no such jail: ${1}"
  "$EDITOR" "/etc/jail.conf.d/${1}.conf"
}

cmd::exec(){
  local usage='exec JAIL COMMAND...'
  local help='Run a command within the jail.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -lt 2 ] && cmd::usage 'COMMAND not specified'
  jail=$1; shift
  jail::exists "$jail" || die "no such jail: ${jail}"

  jail::exec "$jail" "$@"
}

cmd::init(){
  local usage='init'
  local help='Initialize jails dataset.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -eq 0 ] || cmd::usage 'too many arguments'

  # Create the jail parent dataset.
  [ -d "$JAIL_HOME" ] || zfs create -v -o mountpoint="${JAIL_HOME}" "${JAIL_DATASET}"
  chmod 700 "$JAIL_HOME"

  # Download current FreeBSD rootfs and create a template jail.
  local release template
  release=$(uname -r)
  jail::template::release2name template "$release"
  jail::template::exists "$template" || jail::template::download_release "$release"

  # The `jib` script is used to create VNET interfaces. Add it to the PATH.
  install -v -m 0555 /usr/share/examples/jails/jib /usr/local/sbin/jib

  # Add a devfs ruleset to allow BPF within jails.
  if ! grep -xq "\[.*=${JAIL_BPF_RULESET}\]" /etc/devfs.rules 2>/dev/null; then
    cat <<EOF >> /etc/devfs.rules
[devfsrules_jail_vnet_bpf=${JAIL_BPF_RULESET}]
add include \$devfsrules_jail_vnet
add path 'bpf*' unhide
EOF
  fi

  # Enable jails to start on boot.
  sysrc -v jail_enable=YES jail_parallel_start=YES

  # Enable RCTL process accounting for jail resource limits.
  if ! grep -xqF 'kern.racct.enable="1"' /boot/loader.conf; then
    echo 'kern.racct.enable="1"' | tee -a /boot/loader.conf
    echo 'Reboot required to enable resource accounting via RCTL!'
  fi
}

cmd::list(){
  local usage='list [-t]'
  local help='List configured jails.
Options:
  -t  Use terse output (jail names only)'

  local file name status opt terse=false

  while getopts :th opt; do
    case $opt in
      t) terse=true ;;
      h) cmd::help ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -eq 0 ] || cmd::usage 'too many arguments'

  { [ $terse = true ] || echo 'JAIL STATUS'
    for file in /etc/jail.conf.d/*.conf; do
      [ -e "$file" ] || continue

      name=${file##*/}
      name=${name%.conf}

      if [ $terse = true ]; then
        printf '%s\n' "$name"
      else
        if jail::running "$name"; then
          status=running
        else
          status=stopped
        fi
        printf '%s %s\n' "$name" "$status"
      fi
    done
  } | column -t
}

cmd::list_templates(){
  local usage='list-templates'
  local help='list template datasets.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -eq 0 ] || cmd::usage 'too many arguments'

  ls -1 "${JAIL_HOME}/templates"
}

cmd::list_snapshots(){
  local usage='list-snapshots JAIL'
  local help='List jail snapshots
Options:
  -d  List snapshots from data dataset only
  -o  List snapshots from OS dataset only
  -t  Use terse output'

  local opt terse=false dataset=''
  while getopts :dhot opt; do
    case $opt in
      d) dataset='/data' ;;
      h) cmd::help ;;
      o) dataset='/os' ;;
      t) terse=true ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1" || die "no such jail: ${1}"

  if [ "$terse" = true ]; then
    zfs list -r -t snapshot -H -o name -s creation "${JAIL_DATASET}/${1}${dataset}" 2>/dev/null \
      | sed 's/^.*\///' \
      | sort -k1,1 -t@ -s
  else
    { echo 'DATASET SNAPSHOT USED REFER'
      zfs list -r -t snapshot -H -o name,used,refer -s creation "${JAIL_DATASET}/${1}${dataset}" 2>/dev/null
    } | sed 's/^.*\///' \
      | sort -k1,1 -t@ -s \
      | tr '@' ' ' \
      | column -t
  fi
}

cmd::rollback(){
  local usage='rollback JAIL SNAPSHOT'
  local help='Rollback a jail to a given snapshot.
Options:
  -d  Rollback the data dataset only
  -f  Attempt rollback even if the jail is running
  -o  Rollback the OS dataset only'

  local opt force=false both=true os_only=false data_only=false
  while getopts :dfho opt; do
    case $opt in
      d) data_only=true; both=false ;;
      f) force=true ;;
      h) cmd::help ;;
      o) os_only=true; both=false ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -lt 2 ] && cmd::usage 'SNAPSHOT not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  local jail=$1 snapshot=$2

  jail::exists "$jail" || die "no such jail: ${jail}"

  if [ "$both" = true ] || [ "$os_only" = true ]; then
    zfs::dataset_exists "${JAIL_DATASET}/${jail}/os@${snapshot}" \
      || die "no such snapshot for ${jail}/os: ${snapshot}"
  fi
  if [ "$both" = true ] || [ "$data_only" = true ]; then
    zfs::dataset_exists "${JAIL_DATASET}/${jail}/data@${snapshot}" \
      || die "no such snapshot for ${jail}/data: ${snapshot}"
  fi

  if jail::running "$jail" && [ "$force" != true ]; then
    die "jail ${jail} is running, refusing to rollback (-f to override)"
  fi

  if [ "$both" = true ] || [ "$os_only" = true ]; then
    zfs rollback -r "${JAIL_DATASET}/${jail}/os@${snapshot}"
  fi
  if [ "$both" = true ] || [ "$data_only" = true ]; then
    zfs rollback -r "${JAIL_DATASET}/${jail}/data@${snapshot}"
  fi
}

cmd::start(){
  local usage='start JAIL'
  local help='Start a jail.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1"  || die "no such jail: ${1}"
  jail::running "$1" && die "jail already running: ${1}"

  jail::start "$1"
}

cmd::stop(){
  local usage='stop JAIL'
  local help='Stop a jail.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1"  || die "no such jail: ${1}"
  jail::running "$1" || die "jail not running: ${1}"

  jail::stop "$1"
}

cmd::reprovision(){
  local usage='reprovision JAIL TEMPLATE'
  local help="Wipe and reprovision a jail's OS dataset from a template."

  local opt noconfirm=false running=false
  while getopts :hy opt; do
    case $opt in
      h) cmd::help ;;
      y) noconfirm=true ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -lt 2 ] && cmd::usage 'TEMPLATE not specified'
  [ $# -gt 2 ] && cmd::usage 'too many arguments'
  local jail=$1 template=$2

  jail::exists "$jail"               || die "no such jail: ${jail}"
  jail::template::exists "$template" || die "no such template: ${template}"

  if [ "$noconfirm" != true ]; then
    read -rp "Really reprovision ${jail}? (y/N) " answer
    case $answer in
      [yY]|[yY][eE][sS]) : ;;
      *) die 'operation cancelled' ;;
    esac
  fi

  # If the jail is running, stop it.
  if jail::running "$jail"; then
    running=true
    jail::stop "$jail"
  fi

  local snapshot old_quota old_ifconfig old_defaultrouter old_hostname old_resolvconf

  # Get the latest snapshot for the template (if not specified).
  zfs::ensure_snapshot snapshot "${JAIL_DATASET}/templates/${template}"

  # Stash old configuration data.
  old_quota=$(zfs get -Hp -o value quota "${JAIL_DATASET}/${jail}/os")
  old_hostname=$(sysrc -f "${JAIL_HOME}/${jail}/etc/rc.conf" -qn hostname)
  old_ifconfig=$(sysrc -f "${JAIL_HOME}/${jail}/etc/rc.conf" -qn ifconfig_jail0)
  old_defaultrouter=$(sysrc -f "${JAIL_HOME}/${jail}/etc/rc.conf" -qn defaultrouter) ||:
  old_sshkey=$(cat "${JAIL_HOME}/${jail}/root/.ssh/authorized_keys") ||:
  old_resolvconf=$(cat "${JAIL_HOME}/${jail}/etc/resolv.conf") ||:

  # Reprovision OS dataset from template.
  zfs destroy -v -r "${JAIL_DATASET}/${jail}/os"
  zfs clone \
    -o mountpoint="${JAIL_HOME}/${jail}" \
    -o quota="$old_quota" \
    "$snapshot" "${JAIL_DATASET}/${jail}/os"

  # Copy timezone configuration from host.
  cp -v /etc/localtime "${JAIL_HOME}/${jail}/etc/localtime"

  # Restore stashed configuration data.
  sysrc -v -f "${JAIL_HOME}/${jail}/etc/rc.conf" \
    "hostname=${old_hostname}" \
    "ifconfig_e0b_$(jail::name2intf "$jail")_name=jail0" \
    "ifconfig_jail0=${old_ifconfig}" \
    'ipv6_activate_all_interfaces=NO' \
    'syslogd_flags=-ss' \
    'sendmail_enable=NONE' \
    'dumpdev=NO'

  [ -n "$old_defaultrouter" ] && sysrc -f "${JAIL_HOME}/${jail}/etc/rc.conf" "defaultrouter=${old_defaultrouter}"

  [ -n "$old_resolvconf" ] && printf '%s\n' "$old_resolvconf" | tee "${JAIL_HOME}/${jail}/etc/resolv.conf"

  if [ -n "$old_sshkey" ]; then
    echo "PermitRootLogin prohibit-password" | tee -a "${JAIL_HOME}/${jail}/etc/ssh/sshd_config"
    sysrc -v -f "${JAIL_HOME}/${jail}/etc/rc.conf" 'sshd_enable=YES'
    install -v -d -m 0700 "${JAIL_HOME}/${jail}/root/.ssh"
    install -v -m 0600 /dev/null "${JAIL_HOME}/${jail}/root/.ssh/authorized_keys"
    printf '%s\n' "$old_sshkey" | tee "${JAIL_HOME}/${jail}/root/.ssh/authorized_keys"
  fi

  # If the jail was running, restart it.
  if [ "$running" = true ]; then
    jail::start "$jail"
  fi
}

cmd::restart(){
  local usage='restart JAIL'
  local help='Restart a jail.'

  local opt
  while getopts :h opt; do
    case $opt in
      h) cmd::help ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'no jail specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1"  || die "no such jail: ${1}"
  jail::running "$1" || die "jail not running: ${1}"

  jail::restart "$1"
}

cmd::shell(){
  local usage='shell JAIL'
  local help='Run a shell within the jail.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'
  jail::exists "$1"  || die "no such jail: ${1}"
  jail::running "$1" || die "jail not running: ${1}"

  jail::exec "$1" /bin/sh
}

cmd::show(){
  local usage='show JAIL'
  local help='Show jail configuration.'

  local opt
  while getopts :h opt; do
    case $opt in
      h) cmd::help ;;
      ?) cmd::usage "unknown option: -${OPTARG}" ;;
    esac
  done
  shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1" || die "no such jail: ${1}"

  printf -- '------------------------- JAIL CONFIGURATION -------------------------\n'
  cat "/etc/jail.conf.d/${1}.conf"
  printf -- '\n---------------------------- ZFS DATASET -----------------------------\n'
  zfs list -o name,quota,used,avail,mountpoint -S name \
    "${JAIL_DATASET}/${1}/os" \
    "${JAIL_DATASET}/${1}/data"
  printf -- '\n--------------------------- RESOURCE LIMITS --------------------------\n'
  rctl -h "jail:${1}" | cut -d: -f3-
}

cmd::status(){
  local usage='statistics JAIL'
  local help='Show running jail status.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'JAIL not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::exists "$1"  || die "no such jail: ${1}"
  jail::running "$1" || die "jail not running: ${1}"

  printf -- '---------------------------- JAIL STATUS -----------------------------\n'
  jls -j "$1" -h jid name path osrelease host.hostname 2>/dev/null | column -t
  printf -- '\n---------------------------- ZFS DATASET -----------------------------\n'
  zfs list -o name,quota,used,avail,mountpoint -S name \
    "${JAIL_DATASET}/${1}/os" \
    "${JAIL_DATASET}/${1}/data" \
    | sed "s|^${JAIL_DATASET}/${1}/||" \
    | column -t
  printf -- '\n--------------------------- RESOURCE USAGE ---------------------------\n'
  rctl -h -u "jail:${1}" \
    | grep -E '^(maxproc|memoryuse|openfiles|pcpu|vmemoryuse|swapuse|readbps|writebps|readiops|writeiops)=' \
    | rs -c= -C' ' -T \
    | column -t
  printf -- '\n----------------------------- PROCESSES ------------------------------\n'
  ps -auxdr -J "$1"
}

cmd::update_release(){
  local usage='update-release TEMPLATE'
  local help='Update a FreeBSD release template.'

  cmd::getopt_help "$@"; shift $((OPTIND - 1))

  [ $# -lt 1 ] && cmd::usage 'TEMPLATE not specified'
  [ $# -gt 1 ] && cmd::usage 'too many arguments'

  jail::template::exists "$1" || die "no such template: ${1}"
  jail::template::update_release "$1"
}


################################################################################
# "Library" functions.
################################################################################
interface::exists(){
  ifconfig "$1" > /dev/null 2>&1
}

jail::exec() {
  local jail=$1
  shift
  jexec -l "$jail" "$@"
}

jail::exists(){
  test -f "/etc/jail.conf.d/${1}.conf"
}

jail::name2intf(){
  # Usually, most people just use the jail name for the VNET interface name.
  # However...
  #
  # The maximum length of a network interface name on FreeBSD appears to be
  # 15 characters. The `jib` script, which automatically creates VNET bridges,
  # prepends 'e0b_' to the interface name. This leaves only 11 characters for
  # jail name. Any longer, and the you'll get SIOCSIFNAME: File name too long.
  #
  # Rather than write some convoluted logic for truncating the jail name and
  # disambiguating potential clashes, let's do the dumb thing and take a chunk
  # of the jail name's SHA-1 hash :-)
  printf '%s' "$1" | sha1 | tail -c 12
}

jail::restart(){
  jail -v -f "/etc/jail.conf.d/${1}.conf" -rc "$1"
}

jail::running(){
  jls -j "$1" > /dev/null 2>&1
}

jail::start(){
  jail -v -f "/etc/jail.conf.d/${1}.conf" -c "$1"
}

jail::stop(){
  jail -v -f "/etc/jail.conf.d/${1}.conf" -r "$1"
}

jail::template::exists(){
  zfs list -H "${JAIL_DATASET}/templates/${1}" > /dev/null 2>&1
}

jail::template::download_release(){
  # Download a given FreeBSD release and create a template jail.
  local release=$1 arch base_tarball template

  arch=$(uname -p)
  base_tarball="https://download.freebsd.org/releases/${arch}/${release}/base.txz"

  jail::template::release2name template "$release"

  zfs create -v -p "${JAIL_DATASET}/templates/${template}"

  if ! fetch "$base_tarball" -o - | tar xzf - -C "${JAIL_HOME}/templates/${template}"; then
    zfs destroy -v "${JAIL_DATASET}/templates/${template}"
    die "failed to extract base tarball for ${release}"
  fi

  jail::template::update_release "$template"
}

jail::template::release2name(){
  # Convert a FreeBSD release version to a template name.
  # e.g. for "13.2-RELEASE", return "freebsd13".
  setvar "$1" "freebsd${2%.*}"
}

jail::template::update_release(){
  # Run freebsd-update within a the given template and take a fresh snapshot.
  local template=$1 snapshot

  PAGER=/bin/cat freebsd-update -b "${JAIL_HOME}/templates/${template}" --not-running-from-cron fetch install

  snapshot=$("${JAIL_HOME}/templates/${template}/bin/freebsd-version")
  jail::template::exists "${template}@${snapshot}" || zfs snapshot "${JAIL_DATASET}/templates/${template}@${snapshot}"
}

zfs::ensure_snapshot(){
  # If the given zfs dataset is a snapshot, return as-is.
  # Otherwise, get the latest snapshot from the given dataset and return that.
  local upvar=$1 dataset=$2 latest

  if [ "${dataset#*@}" = "$dataset" ]; then
    latest=$(zfs list -t snapshot -o name -s creation -H "$dataset" | tail -1)
    setvar "$upvar" "$latest"
  else
    zfs list -t snapshot -H "$dataset" > /dev/null 2>&1 || die "no such snapshot: ${dataset}"
    setvar "$upvar" "$dataset"
  fi
}

zfs::dataset_exists(){
  zfs list "$1" > /dev/null 2>&1
}


cmd::main "$@"
